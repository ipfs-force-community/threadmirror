// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: mention.sql

package sqlc_generated

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countMentions = `-- name: CountMentions :one
SELECT COUNT(*) FROM mention m
WHERE ($1::text IS NULL OR m.user_id = $1)
`

type CountMentionsParams struct {
	UserID string `json:"user_id"`
}

func (q *Queries) CountMentions(ctx context.Context, arg CountMentionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMentions, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMentionsByUser = `-- name: CountMentionsByUser :one
SELECT COUNT(*) FROM mention m
WHERE m.user_id = $1
`

type CountMentionsByUserParams struct {
	UserID string `json:"user_id"`
}

func (q *Queries) CountMentionsByUser(ctx context.Context, arg CountMentionsByUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMentionsByUser, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMention = `-- name: CreateMention :one
INSERT INTO mention (
    id, user_id, thread_id, mention_create_at
) VALUES (
    $1, $2, $3, $4
) RETURNING id, user_id, thread_id, mention_create_at, created_at, updated_at
`

type CreateMentionParams struct {
	ID              uuid.UUID `json:"id"`
	UserID          string    `json:"user_id"`
	ThreadID        uuid.UUID `json:"thread_id"`
	MentionCreateAt time.Time `json:"mention_create_at"`
}

func (q *Queries) CreateMention(ctx context.Context, arg CreateMentionParams) (Mention, error) {
	row := q.db.QueryRow(ctx, createMention,
		arg.ID,
		arg.UserID,
		arg.ThreadID,
		arg.MentionCreateAt,
	)
	var i Mention
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ThreadID,
		&i.MentionCreateAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMentionByID = `-- name: GetMentionByID :one

SELECT m.id, m.user_id, m.thread_id, m.mention_create_at, m.created_at, m.updated_at, t.id, t.summary, t.cid, t.num_tweets, t.status, t.retry_count, t.version, t.author_id, t.author_name, t.author_screen_name, t.author_profile_image_url, t.created_at, t.updated_at FROM mention m
JOIN thread t ON m.thread_id = t.id
WHERE m.id = $1
`

type GetMentionByIDParams struct {
	MentionID uuid.UUID `json:"mention_id"`
}

type GetMentionByIDRow struct {
	ID                    uuid.UUID `json:"id"`
	UserID                string    `json:"user_id"`
	ThreadID              uuid.UUID `json:"thread_id"`
	MentionCreateAt       time.Time `json:"mention_create_at"`
	CreatedAt             time.Time `json:"created_at"`
	UpdatedAt             time.Time `json:"updated_at"`
	ID_2                  uuid.UUID `json:"id_2"`
	Summary               string    `json:"summary"`
	Cid                   string    `json:"cid"`
	NumTweets             int32     `json:"num_tweets"`
	Status                string    `json:"status"`
	RetryCount            int32     `json:"retry_count"`
	Version               int32     `json:"version"`
	AuthorID              *string   `json:"author_id"`
	AuthorName            *string   `json:"author_name"`
	AuthorScreenName      *string   `json:"author_screen_name"`
	AuthorProfileImageUrl *string   `json:"author_profile_image_url"`
	CreatedAt_2           time.Time `json:"created_at_2"`
	UpdatedAt_2           time.Time `json:"updated_at_2"`
}

// Mention queries
func (q *Queries) GetMentionByID(ctx context.Context, arg GetMentionByIDParams) (GetMentionByIDRow, error) {
	row := q.db.QueryRow(ctx, getMentionByID, arg.MentionID)
	var i GetMentionByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ThreadID,
		&i.MentionCreateAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.Summary,
		&i.Cid,
		&i.NumTweets,
		&i.Status,
		&i.RetryCount,
		&i.Version,
		&i.AuthorID,
		&i.AuthorName,
		&i.AuthorScreenName,
		&i.AuthorProfileImageUrl,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getMentionByUserIDAndThreadID = `-- name: GetMentionByUserIDAndThreadID :one
SELECT m.id, m.user_id, m.thread_id, m.mention_create_at, m.created_at, m.updated_at, t.id, t.summary, t.cid, t.num_tweets, t.status, t.retry_count, t.version, t.author_id, t.author_name, t.author_screen_name, t.author_profile_image_url, t.created_at, t.updated_at FROM mention m
JOIN thread t ON m.thread_id = t.id
WHERE m.user_id = $1 AND m.thread_id = $2
`

type GetMentionByUserIDAndThreadIDParams struct {
	UserID   string    `json:"user_id"`
	ThreadID uuid.UUID `json:"thread_id"`
}

type GetMentionByUserIDAndThreadIDRow struct {
	ID                    uuid.UUID `json:"id"`
	UserID                string    `json:"user_id"`
	ThreadID              uuid.UUID `json:"thread_id"`
	MentionCreateAt       time.Time `json:"mention_create_at"`
	CreatedAt             time.Time `json:"created_at"`
	UpdatedAt             time.Time `json:"updated_at"`
	ID_2                  uuid.UUID `json:"id_2"`
	Summary               string    `json:"summary"`
	Cid                   string    `json:"cid"`
	NumTweets             int32     `json:"num_tweets"`
	Status                string    `json:"status"`
	RetryCount            int32     `json:"retry_count"`
	Version               int32     `json:"version"`
	AuthorID              *string   `json:"author_id"`
	AuthorName            *string   `json:"author_name"`
	AuthorScreenName      *string   `json:"author_screen_name"`
	AuthorProfileImageUrl *string   `json:"author_profile_image_url"`
	CreatedAt_2           time.Time `json:"created_at_2"`
	UpdatedAt_2           time.Time `json:"updated_at_2"`
}

func (q *Queries) GetMentionByUserIDAndThreadID(ctx context.Context, arg GetMentionByUserIDAndThreadIDParams) (GetMentionByUserIDAndThreadIDRow, error) {
	row := q.db.QueryRow(ctx, getMentionByUserIDAndThreadID, arg.UserID, arg.ThreadID)
	var i GetMentionByUserIDAndThreadIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ThreadID,
		&i.MentionCreateAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.Summary,
		&i.Cid,
		&i.NumTweets,
		&i.Status,
		&i.RetryCount,
		&i.Version,
		&i.AuthorID,
		&i.AuthorName,
		&i.AuthorScreenName,
		&i.AuthorProfileImageUrl,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getMentions = `-- name: GetMentions :many
SELECT m.id, m.user_id, m.thread_id, m.mention_create_at, m.created_at, m.updated_at, t.id, t.summary, t.cid, t.num_tweets, t.status, t.retry_count, t.version, t.author_id, t.author_name, t.author_screen_name, t.author_profile_image_url, t.created_at, t.updated_at FROM mention m
JOIN thread t ON m.thread_id = t.id
WHERE ($1::text IS NULL OR m.user_id = $1)
ORDER BY m.created_at DESC
LIMIT $3 OFFSET $2
`

type GetMentionsParams struct {
	UserID string `json:"user_id"`
	Offset int32  `json:"offset_"`
	Limit  int32  `json:"limit_"`
}

type GetMentionsRow struct {
	ID                    uuid.UUID `json:"id"`
	UserID                string    `json:"user_id"`
	ThreadID              uuid.UUID `json:"thread_id"`
	MentionCreateAt       time.Time `json:"mention_create_at"`
	CreatedAt             time.Time `json:"created_at"`
	UpdatedAt             time.Time `json:"updated_at"`
	ID_2                  uuid.UUID `json:"id_2"`
	Summary               string    `json:"summary"`
	Cid                   string    `json:"cid"`
	NumTweets             int32     `json:"num_tweets"`
	Status                string    `json:"status"`
	RetryCount            int32     `json:"retry_count"`
	Version               int32     `json:"version"`
	AuthorID              *string   `json:"author_id"`
	AuthorName            *string   `json:"author_name"`
	AuthorScreenName      *string   `json:"author_screen_name"`
	AuthorProfileImageUrl *string   `json:"author_profile_image_url"`
	CreatedAt_2           time.Time `json:"created_at_2"`
	UpdatedAt_2           time.Time `json:"updated_at_2"`
}

func (q *Queries) GetMentions(ctx context.Context, arg GetMentionsParams) ([]GetMentionsRow, error) {
	rows, err := q.db.Query(ctx, getMentions, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMentionsRow
	for rows.Next() {
		var i GetMentionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ThreadID,
			&i.MentionCreateAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Summary,
			&i.Cid,
			&i.NumTweets,
			&i.Status,
			&i.RetryCount,
			&i.Version,
			&i.AuthorID,
			&i.AuthorName,
			&i.AuthorScreenName,
			&i.AuthorProfileImageUrl,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMentionsByUser = `-- name: GetMentionsByUser :many
SELECT m.id, m.user_id, m.thread_id, m.mention_create_at, m.created_at, m.updated_at, t.id, t.summary, t.cid, t.num_tweets, t.status, t.retry_count, t.version, t.author_id, t.author_name, t.author_screen_name, t.author_profile_image_url, t.created_at, t.updated_at FROM mention m
JOIN thread t ON m.thread_id = t.id
WHERE m.user_id = $1
ORDER BY m.created_at DESC
LIMIT $3 OFFSET $2
`

type GetMentionsByUserParams struct {
	UserID string `json:"user_id"`
	Offset int32  `json:"offset_"`
	Limit  int32  `json:"limit_"`
}

type GetMentionsByUserRow struct {
	ID                    uuid.UUID `json:"id"`
	UserID                string    `json:"user_id"`
	ThreadID              uuid.UUID `json:"thread_id"`
	MentionCreateAt       time.Time `json:"mention_create_at"`
	CreatedAt             time.Time `json:"created_at"`
	UpdatedAt             time.Time `json:"updated_at"`
	ID_2                  uuid.UUID `json:"id_2"`
	Summary               string    `json:"summary"`
	Cid                   string    `json:"cid"`
	NumTweets             int32     `json:"num_tweets"`
	Status                string    `json:"status"`
	RetryCount            int32     `json:"retry_count"`
	Version               int32     `json:"version"`
	AuthorID              *string   `json:"author_id"`
	AuthorName            *string   `json:"author_name"`
	AuthorScreenName      *string   `json:"author_screen_name"`
	AuthorProfileImageUrl *string   `json:"author_profile_image_url"`
	CreatedAt_2           time.Time `json:"created_at_2"`
	UpdatedAt_2           time.Time `json:"updated_at_2"`
}

func (q *Queries) GetMentionsByUser(ctx context.Context, arg GetMentionsByUserParams) ([]GetMentionsByUserRow, error) {
	rows, err := q.db.Query(ctx, getMentionsByUser, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMentionsByUserRow
	for rows.Next() {
		var i GetMentionsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ThreadID,
			&i.MentionCreateAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Summary,
			&i.Cid,
			&i.NumTweets,
			&i.Status,
			&i.RetryCount,
			&i.Version,
			&i.AuthorID,
			&i.AuthorName,
			&i.AuthorScreenName,
			&i.AuthorProfileImageUrl,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMention = `-- name: UpdateMention :exec
UPDATE mention SET
    user_id = $1,
    thread_id = $2,
    mention_create_at = $3,
    updated_at = NOW()
WHERE id = $4
`

type UpdateMentionParams struct {
	UserID          string    `json:"user_id"`
	ThreadID        uuid.UUID `json:"thread_id"`
	MentionCreateAt time.Time `json:"mention_create_at"`
	ID              uuid.UUID `json:"id"`
}

func (q *Queries) UpdateMention(ctx context.Context, arg UpdateMentionParams) error {
	_, err := q.db.Exec(ctx, updateMention,
		arg.UserID,
		arg.ThreadID,
		arg.MentionCreateAt,
		arg.ID,
	)
	return err
}
