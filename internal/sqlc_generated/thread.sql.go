// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: thread.sql

package sqlc_generated

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createThread = `-- name: CreateThread :one
INSERT INTO thread (
    id, summary, cid, num_tweets, status, retry_count, version,
    author_id, author_name, author_screen_name, author_profile_image_url
) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11
) RETURNING id, summary, cid, num_tweets, status, retry_count, version, author_id, author_name, author_screen_name, author_profile_image_url, created_at, updated_at
`

type CreateThreadParams struct {
	ID                    uuid.UUID `json:"id"`
	Summary               string    `json:"summary"`
	Cid                   string    `json:"cid"`
	NumTweets             int32     `json:"num_tweets"`
	Status                string    `json:"status"`
	RetryCount            int32     `json:"retry_count"`
	Version               int32     `json:"version"`
	AuthorID              *string   `json:"author_id"`
	AuthorName            *string   `json:"author_name"`
	AuthorScreenName      *string   `json:"author_screen_name"`
	AuthorProfileImageUrl *string   `json:"author_profile_image_url"`
}

func (q *Queries) CreateThread(ctx context.Context, arg CreateThreadParams) (Thread, error) {
	row := q.db.QueryRow(ctx, createThread,
		arg.ID,
		arg.Summary,
		arg.Cid,
		arg.NumTweets,
		arg.Status,
		arg.RetryCount,
		arg.Version,
		arg.AuthorID,
		arg.AuthorName,
		arg.AuthorScreenName,
		arg.AuthorProfileImageUrl,
	)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.Summary,
		&i.Cid,
		&i.NumTweets,
		&i.Status,
		&i.RetryCount,
		&i.Version,
		&i.AuthorID,
		&i.AuthorName,
		&i.AuthorScreenName,
		&i.AuthorProfileImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFailedThreadsForRetry = `-- name: GetFailedThreadsForRetry :many
SELECT id, summary, cid, num_tweets, status, retry_count, version, author_id, author_name, author_screen_name, author_profile_image_url, created_at, updated_at FROM thread 
WHERE status = 'failed' 
  AND updated_at < $1 
  AND retry_count < $2
FOR UPDATE
`

type GetFailedThreadsForRetryParams struct {
	CutoffTime time.Time `json:"cutoff_time"`
	MaxRetries int32     `json:"max_retries"`
}

func (q *Queries) GetFailedThreadsForRetry(ctx context.Context, arg GetFailedThreadsForRetryParams) ([]Thread, error) {
	rows, err := q.db.Query(ctx, getFailedThreadsForRetry, arg.CutoffTime, arg.MaxRetries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thread
	for rows.Next() {
		var i Thread
		if err := rows.Scan(
			&i.ID,
			&i.Summary,
			&i.Cid,
			&i.NumTweets,
			&i.Status,
			&i.RetryCount,
			&i.Version,
			&i.AuthorID,
			&i.AuthorName,
			&i.AuthorScreenName,
			&i.AuthorProfileImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOldPendingThreads = `-- name: GetOldPendingThreads :many
SELECT id, summary, cid, num_tweets, status, retry_count, version, author_id, author_name, author_screen_name, author_profile_image_url, created_at, updated_at FROM thread 
WHERE status = 'pending' 
  AND created_at < $1 
  AND retry_count < $2
FOR UPDATE
`

type GetOldPendingThreadsParams struct {
	CutoffTime time.Time `json:"cutoff_time"`
	MaxRetries int32     `json:"max_retries"`
}

func (q *Queries) GetOldPendingThreads(ctx context.Context, arg GetOldPendingThreadsParams) ([]Thread, error) {
	rows, err := q.db.Query(ctx, getOldPendingThreads, arg.CutoffTime, arg.MaxRetries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thread
	for rows.Next() {
		var i Thread
		if err := rows.Scan(
			&i.ID,
			&i.Summary,
			&i.Cid,
			&i.NumTweets,
			&i.Status,
			&i.RetryCount,
			&i.Version,
			&i.AuthorID,
			&i.AuthorName,
			&i.AuthorScreenName,
			&i.AuthorProfileImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStuckScrapingThreads = `-- name: GetStuckScrapingThreads :many
SELECT id, summary, cid, num_tweets, status, retry_count, version, author_id, author_name, author_screen_name, author_profile_image_url, created_at, updated_at FROM thread 
WHERE status = 'scraping' 
  AND updated_at < $1 
  AND retry_count < $2
FOR UPDATE
`

type GetStuckScrapingThreadsParams struct {
	CutoffTime time.Time `json:"cutoff_time"`
	MaxRetries int32     `json:"max_retries"`
}

func (q *Queries) GetStuckScrapingThreads(ctx context.Context, arg GetStuckScrapingThreadsParams) ([]Thread, error) {
	rows, err := q.db.Query(ctx, getStuckScrapingThreads, arg.CutoffTime, arg.MaxRetries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thread
	for rows.Next() {
		var i Thread
		if err := rows.Scan(
			&i.ID,
			&i.Summary,
			&i.Cid,
			&i.NumTweets,
			&i.Status,
			&i.RetryCount,
			&i.Version,
			&i.AuthorID,
			&i.AuthorName,
			&i.AuthorScreenName,
			&i.AuthorProfileImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreadByID = `-- name: GetThreadByID :one

SELECT id, summary, cid, num_tweets, status, retry_count, version, author_id, author_name, author_screen_name, author_profile_image_url, created_at, updated_at FROM thread WHERE id = $1
`

type GetThreadByIDParams struct {
	ThreadID uuid.UUID `json:"thread_id"`
}

// Thread queries
func (q *Queries) GetThreadByID(ctx context.Context, arg GetThreadByIDParams) (Thread, error) {
	row := q.db.QueryRow(ctx, getThreadByID, arg.ThreadID)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.Summary,
		&i.Cid,
		&i.NumTweets,
		&i.Status,
		&i.RetryCount,
		&i.Version,
		&i.AuthorID,
		&i.AuthorName,
		&i.AuthorScreenName,
		&i.AuthorProfileImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getThreadsByIDs = `-- name: GetThreadsByIDs :many
SELECT id, summary, cid, num_tweets, status, retry_count, version, author_id, author_name, author_screen_name, author_profile_image_url, created_at, updated_at FROM thread WHERE id = ANY($1::uuid[])
`

type GetThreadsByIDsParams struct {
	ThreadIds []uuid.UUID `json:"thread_ids"`
}

func (q *Queries) GetThreadsByIDs(ctx context.Context, arg GetThreadsByIDsParams) ([]Thread, error) {
	rows, err := q.db.Query(ctx, getThreadsByIDs, arg.ThreadIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thread
	for rows.Next() {
		var i Thread
		if err := rows.Scan(
			&i.ID,
			&i.Summary,
			&i.Cid,
			&i.NumTweets,
			&i.Status,
			&i.RetryCount,
			&i.Version,
			&i.AuthorID,
			&i.AuthorName,
			&i.AuthorScreenName,
			&i.AuthorProfileImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementThreadRetryCount = `-- name: IncrementThreadRetryCount :exec
UPDATE thread SET 
    retry_count = retry_count + 1,
    updated_at = NOW()
WHERE id = ANY($1::uuid[])
`

type IncrementThreadRetryCountParams struct {
	ThreadIds []uuid.UUID `json:"thread_ids"`
}

func (q *Queries) IncrementThreadRetryCount(ctx context.Context, arg IncrementThreadRetryCountParams) error {
	_, err := q.db.Exec(ctx, incrementThreadRetryCount, arg.ThreadIds)
	return err
}

const updateThreadComplete = `-- name: UpdateThreadComplete :exec
UPDATE thread SET
    summary = $1,
    cid = $2,
    num_tweets = $3,
    status = $4,
    retry_count = $5,
    version = version + 1,
    author_id = $6,
    author_name = $7,
    author_screen_name = $8,
    author_profile_image_url = $9,
    updated_at = NOW()
WHERE id = $10 AND version = $11
`

type UpdateThreadCompleteParams struct {
	Summary               string    `json:"summary"`
	Cid                   string    `json:"cid"`
	NumTweets             int32     `json:"num_tweets"`
	Status                string    `json:"status"`
	RetryCount            int32     `json:"retry_count"`
	AuthorID              *string   `json:"author_id"`
	AuthorName            *string   `json:"author_name"`
	AuthorScreenName      *string   `json:"author_screen_name"`
	AuthorProfileImageUrl *string   `json:"author_profile_image_url"`
	ID                    uuid.UUID `json:"id"`
	ExpectedVersion       int32     `json:"expected_version"`
}

func (q *Queries) UpdateThreadComplete(ctx context.Context, arg UpdateThreadCompleteParams) error {
	_, err := q.db.Exec(ctx, updateThreadComplete,
		arg.Summary,
		arg.Cid,
		arg.NumTweets,
		arg.Status,
		arg.RetryCount,
		arg.AuthorID,
		arg.AuthorName,
		arg.AuthorScreenName,
		arg.AuthorProfileImageUrl,
		arg.ID,
		arg.ExpectedVersion,
	)
	return err
}

const updateThreadStatus = `-- name: UpdateThreadStatus :exec
UPDATE thread SET
    status = $1,
    version = version + 1,
    updated_at = NOW()
WHERE id = $2 AND version = $3
`

type UpdateThreadStatusParams struct {
	Status         string    `json:"status"`
	ThreadID       uuid.UUID `json:"thread_id"`
	CurrentVersion int32     `json:"current_version"`
}

func (q *Queries) UpdateThreadStatus(ctx context.Context, arg UpdateThreadStatusParams) error {
	_, err := q.db.Exec(ctx, updateThreadStatus, arg.Status, arg.ThreadID, arg.CurrentVersion)
	return err
}
