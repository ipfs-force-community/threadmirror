// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: processed_mark.sql

package sqlc_generated

import (
	"context"
	"time"
)

const createProcessedMark = `-- name: CreateProcessedMark :one
INSERT INTO processed_mark (key, type) 
VALUES ($1, $2) 
RETURNING key, type, created_at, updated_at
`

type CreateProcessedMarkParams struct {
	Key  string `json:"key"`
	Type string `json:"type"`
}

func (q *Queries) CreateProcessedMark(ctx context.Context, arg CreateProcessedMarkParams) (ProcessedMark, error) {
	row := q.db.QueryRow(ctx, createProcessedMark, arg.Key, arg.Type)
	var i ProcessedMark
	err := row.Scan(
		&i.Key,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOldProcessedMarks = `-- name: DeleteOldProcessedMarks :exec
DELETE FROM processed_mark WHERE created_at < $1
`

type DeleteOldProcessedMarksParams struct {
	CutoffTime time.Time `json:"cutoff_time"`
}

func (q *Queries) DeleteOldProcessedMarks(ctx context.Context, arg DeleteOldProcessedMarksParams) error {
	_, err := q.db.Exec(ctx, deleteOldProcessedMarks, arg.CutoffTime)
	return err
}

const deleteProcessedMark = `-- name: DeleteProcessedMark :exec
DELETE FROM processed_mark WHERE key = $1 AND type = $2
`

type DeleteProcessedMarkParams struct {
	Key  string `json:"key"`
	Type string `json:"type"`
}

func (q *Queries) DeleteProcessedMark(ctx context.Context, arg DeleteProcessedMarkParams) error {
	_, err := q.db.Exec(ctx, deleteProcessedMark, arg.Key, arg.Type)
	return err
}

const getProcessedMark = `-- name: GetProcessedMark :one

SELECT key, type, created_at, updated_at FROM processed_mark WHERE key = $1 AND type = $2
`

type GetProcessedMarkParams struct {
	Key  string `json:"key"`
	Type string `json:"type"`
}

// ProcessedMark queries
func (q *Queries) GetProcessedMark(ctx context.Context, arg GetProcessedMarkParams) (ProcessedMark, error) {
	row := q.db.QueryRow(ctx, getProcessedMark, arg.Key, arg.Type)
	var i ProcessedMark
	err := row.Scan(
		&i.Key,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertProcessedMark = `-- name: UpsertProcessedMark :one
INSERT INTO processed_mark (key, type) 
VALUES ($1, $2)
ON CONFLICT (key, type) DO UPDATE SET
    updated_at = NOW()
RETURNING key, type, created_at, updated_at
`

type UpsertProcessedMarkParams struct {
	Key  string `json:"key"`
	Type string `json:"type"`
}

func (q *Queries) UpsertProcessedMark(ctx context.Context, arg UpsertProcessedMarkParams) (ProcessedMark, error) {
	row := q.db.QueryRow(ctx, upsertProcessedMark, arg.Key, arg.Type)
	var i ProcessedMark
	err := row.Scan(
		&i.Key,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
