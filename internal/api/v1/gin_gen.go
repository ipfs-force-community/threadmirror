// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Get mentions feed
	// (GET /mentions)
	GetMentions(c *gin.Context, params GetMentionsParams)
	// Render QR code
	// (GET /qrcode)
	GetQrcode(c *gin.Context, params GetQrcodeParams)
	// Render thread as HTML
	// (GET /render)
	GetRender(c *gin.Context, params GetRenderParams)
	// Download share image
	// (GET /share)
	GetShare(c *gin.Context, params GetShareParams)
	// Get thread details
	// (GET /thread/{id})
	GetThreadId(c *gin.Context, id string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// GetMentions operation middleware
func (siw *ServerInterfaceWrapper) GetMentions(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMentionsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetMentions(c, params)
}

// GetQrcode operation middleware
func (siw *ServerInterfaceWrapper) GetQrcode(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetQrcodeParams

	// ------------- Required query parameter "thread_id" -------------

	if paramValue := c.Query("thread_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument thread_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "thread_id", c.Request.URL.Query(), &params.ThreadId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter thread_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetQrcode(c, params)
}

// GetRender operation middleware
func (siw *ServerInterfaceWrapper) GetRender(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRenderParams

	// ------------- Required query parameter "thread_id" -------------

	if paramValue := c.Query("thread_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument thread_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "thread_id", c.Request.URL.Query(), &params.ThreadId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter thread_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRender(c, params)
}

// GetShare operation middleware
func (siw *ServerInterfaceWrapper) GetShare(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShareParams

	// ------------- Required query parameter "thread_id" -------------

	if paramValue := c.Query("thread_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument thread_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "thread_id", c.Request.URL.Query(), &params.ThreadId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter thread_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetShare(c, params)
}

// GetThreadId operation middleware
func (siw *ServerInterfaceWrapper) GetThreadId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetThreadId(c, id)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.GET(options.BaseURL+"/mentions", wrapper.GetMentions)
	router.GET(options.BaseURL+"/qrcode", wrapper.GetQrcode)
	router.GET(options.BaseURL+"/render", wrapper.GetRender)
	router.GET(options.BaseURL+"/share", wrapper.GetShare)
	router.GET(options.BaseURL+"/thread/:id", wrapper.GetThreadId)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9RaX2/bOBL/KoRugWsBbey2u8DCT9c23TaHZC8bJ9iHIhBoaWxxI5EqSTn1Ff7uB3Ko",
	"fxZlqUm6131KZA2Hw5nf/OFovgSxyAvBgWsVLL4EBZU0Bw3SPl3SDZyznGnzkICKJSs0EzxYBBf0M8vL",
	"nPAyX4EkYk2YhlwRLYgEXUoehAEzhJ9KkLsgDDjNIVgEmWUXBipOIafId03LTAeLl/MwyJFtsHgxN0+M",
	"u6cw0LvCrGdcwwZksN+HVrz/rNcKPPL91pdL3bFiQCqBXLxiteWYe+TYh4EEVQiuwCrtDU2u4FMJykoV",
	"C66B239pUWQspkbA2Z/KSPmltd8PEtbBIvjHrDHIDN+q2Tsphduqe8o3NCHSbbYPgzOuQXKaLUFuQeKq",
	"by5DtSlRdlcCSBgGvwn9qyh58u1FuAIlShkD4UKTtd1zHwY3nJY6FZL9F/4CGdq7kR+JeQCu3SbWSExC",
	"YnHreJmtahsVUhQgNUMMxSKBPqYtMbHvwmAtZE41IvHVy6APzDDIQSm6GWRUva6XKi0Z3wSIaCfv4mPg",
	"NqzIb2t6sfoTYgu8D1Slmm76B2E8YTH+2xVhqanUhPKEAE+IIyOME50C0fcAmmj4bFzS+q9h4Dkg/XyG",
	"b19aJ20eHC2Vku4MpeXVE8KJbXciz+6ZTkWpR/VRyeWO5tPHBSSM9rWRMFVkdBeVMusLc4ovyc3VOVlb",
	"8xgePWHCAD4XlCeQ+Nm8c297fGrAlJL52LIkUlp6Ir1ZT0rOPpVAWGJAvWYgvSy+E2vbI0d3sBs6zR3s",
	"Ro6CLEqZRanWhedIH66vL5eoXKPqCQrGH/wCmXfkWZEKLUKyZQmIkICOT577GHntfjFZkgM4O7u3teaW",
	"4E5hB7YH8OsraswxuJF3WeY5lTtP4GNJ/2hvMXC3LEaevT079erGBfmokLBlcO/Tk5WAOELiCGfKiWRx",
	"dg58o9Ng8fN87ttDAtWQRFQfYW9ozD+a5aA0zYu2XRKq4Ufzxu+Iw2wnuWGOxBHKeVRM9L1HCMvLPLJM",
	"1LEaDClqh08l0MSbsvBVhKl0LBdfW+LXSNss9ukPSaeor+cdQWhR2YdWe8MOKHwW6GjK5xmXdMO4tcIF",
	"aE/uyL6uDsciHPxaFhOLZlMxFwM8tNDUE4auzc+H0gTe8r2TUy23sL4eOAl9ilru8pXI/m6lBkrdrTTI",
	"D8+fotjouEFfLR5vQNp/qr4/kGfX90xrkKRUIMlAkMVb0yBXly+IJfMsL6RYswwiltMN+KuYmpejJZZ2",
	"YqJVsQTg0YiUSGWFbCzyr+fTIoI7Wnsn37mGzXUKmrLs/5EAXSj8Rvmv4v606W96+H76jDTA6hoZUKVE",
	"zIw6iMEQ0SlT5LpiVweUo2nMcELJs4yuMggWWpZwGFm+JjF1klFLIfVxvMCsTfVUsfUJo6qCWPDEJwG+",
	"IFualWAt20Kcx5ze6FwfvZJ5JAQ4dTRiOcZetVrz9lQ6scQxi28Uyh4LvgWprGNFA3GiJnCYHnGWo678",
	"2NrQbFwdd/SQ7yrifRikVEUrJpN7quM04kL7oPdHCjoFiR6HaTyliryp1hFcV8u1EiIDygdDjOUw8Zob",
	"SSiyXaRFpDTVpfJa4+zUwrEpMoygzJRmRbZjfEO0CAad3r+bScoje9m8/dCtVPSpFBrcqUZ0zhShxNLj",
	"Af2qVij9FF5IOMhFV440zueoPFpSrjKqURWD7BD9lJMVkGpJuxZuMc0o3wwhyrwrTe3i2mj9akgoxVbZ",
	"LlLAFdNse0SoKmnnbJNqI1izxieXNU4S1YqblIUkKB0Ne8jVu+U1eX15NuIj2JD1hGts1LYasFOAafA4",
	"LYwsLeVwoK/L/UqXPuFNFj1aPSDBoOBDtxybrSv9hlVt30nWeNIO4ltO1HfRflbwh08HUi/c+l4xmMfe",
	"tUJ6N5+l2EtVg13W7pVranFUdZb3A12+oUYY1ZrGaW6/a03cCpu2o3VYGCh7l/Oc9FfGKY8ZzYgjedCR",
	"3QXXc+I6BasjJczDNm2KvwkKKKXv9DdX5w/b+0Z6T2uTneuk+LYzia56/bB9FUjXCOvvf+C6Nbwb8zs9",
	"HAo66DvLKoh1HWclxF1O5V0Ui5IfbcpUlMpb2a7pVkimYZxPxu5AzSp6PzcMMqOsWunfzwdLl1E+hozB",
	"EAvLfwqTI4KYkD3O4oGBvX3KQ4F7lukqNzwEwCB+7DWg3zA4UsFbF6Gx5fuYQr7D1bvJiolZ+2cPk7XI",
	"MnEPUo1boSb1A10y4MlkNsymvT4bX4ljzzLtDqCiVVZCtAVpaJLhms0W5OZmYugJ0teVT79m83etrGBP",
	"0FezfB7SUxusCi3HqUXhscacZTS5KYeVUqlgAg6ORYVp5mOK1JR9ox2v8ia2Crte1neXQ9z3FHBQSLbk",
	"7WHVF2JuZDb6wXr0U/SEy2zdSDrSFvLUG57tD9Te/UrZtGiG+rDt7D+pa+6IIbGY8HXPv+dv4n6n651p",
	"LMYcdeEet0f12Lse4/4MfwjBJmEpmd4tTYHnprGASpCvS53aWss+/VrFun//cV3NfFmHtm8b4VKtCxz1",
	"YXwtqhEiGttg4ybHTNBblkUhpHZYw3VqMZttmE7L1Uks8hl8pnmRwQybcjmrZqQOvk1cnuHIBuV0w/gG",
	"g4+LFcpiBcOCDWZMG0dzvXFkSd7Q+M7A6fXlGcYAhZxfnMxP5vbTXwGcFixYBK9O5ievTCiiOrWqmqVA",
	"M9TTxtdoeZtCfEcYtpkUyC2LwURGXLaz4smSc0y4xptsljtLgkXwHvQH5H4wLfdyPv+q2ayumzZ9KuBl",
	"bpAj7gw0nLoNOu68oxjtVvfBKUspgetqms2VRNPqpFrf/SY1aqsiaEuIphnziPq634jucYEeopY9Mxk5",
	"f56/eoTSHzpWFnrMhcOCHYvhT2NGm2KQcRUem2o7qsyS1+psxZ1g8fE2DKovaYsAIU9i4zhmX9se+eh+",
	"Dm7N0ln7gut1u/egCSUFjgdAQjKmtKlq6qvvWoq8Kpkx8ioiJCnKVcbimsznkhfNu/bg70f/tbkhmTWD",
	"wftwErEb093fPqn7JxQnJSa2dzqjR96Gkh6d/zwY09jvJ+Dm/MBiZq+f5i+GtqoVNOtMsFq/nY8v8g0B",
	"W5DWsDSIatADWNM6bNaQQHR+ktUo6gA2uYEUYOy3IyeEkt+vbLPb3S9MQjMZY8O20Poq5cPj79I1yQ/Q",
	"ePgxGBo2RAsCHLfD0sntPjDp3R7ZaYIDVqsNzA4DyThs7VlnBX4HaBjVYWrFOH5dP2TdQ0tXe88uf3v/",
	"HAEzwfat2fNHw2Ugpl0BT0C2tFwh5/ert+YHxI20VIO4cUxoZUdqihvy4fri3AQ6P2YiP2aQ1VdjRlbL",
	"/kqQmHp+luo8GwCJfTUBInhmSBqNPRAhP81/Gl9Sz/F/Y0g1WDDHaiHLmRiRpVIqhwPSqbjnmTBcSCb4",
	"xjmRhEKCAq6xAVZ9lcX9DNYM04GydWn3+1p4barAaGtlwwJF+dtGpWVzhkfFpO8DcTVMuqapAIc2R7yh",
	"aWZfWLI/WqIldqALzE0e1WuQRlfmwkuJKiBmaxY3g0Y9nOE17iwZh5qF2dlpBSVzf2uQ9OQQekg9Nj60",
	"68bfJpVP7sSoYPX9gOi9nenoynZAX3UcsP/w8dboGy+WPtOewhYyUeTN9bPTUljMZpmIaZYKpRe/zH+Z",
	"z2jBZtsXwf52/78AAAD//2ySt+zINwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
