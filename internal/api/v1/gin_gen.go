// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Get mentions feed
	// (GET /mentions)
	GetMentions(c *gin.Context, params GetMentionsParams)
	// Render QR code
	// (GET /qrcode)
	GetQrcode(c *gin.Context, params GetQrcodeParams)
	// Render thread as HTML
	// (GET /render)
	GetRender(c *gin.Context, params GetRenderParams)
	// Download share image
	// (GET /share)
	GetShare(c *gin.Context, params GetShareParams)
	// Scrape Twitter thread from URL (Async)
	// (POST /thread/scrape)
	PostThreadScrape(c *gin.Context)
	// Get thread details
	// (GET /thread/{id})
	GetThreadId(c *gin.Context, id string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// GetMentions operation middleware
func (siw *ServerInterfaceWrapper) GetMentions(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMentionsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetMentions(c, params)
}

// GetQrcode operation middleware
func (siw *ServerInterfaceWrapper) GetQrcode(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetQrcodeParams

	// ------------- Required query parameter "thread_id" -------------

	if paramValue := c.Query("thread_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument thread_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "thread_id", c.Request.URL.Query(), &params.ThreadId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter thread_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetQrcode(c, params)
}

// GetRender operation middleware
func (siw *ServerInterfaceWrapper) GetRender(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRenderParams

	// ------------- Required query parameter "thread_id" -------------

	if paramValue := c.Query("thread_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument thread_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "thread_id", c.Request.URL.Query(), &params.ThreadId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter thread_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRender(c, params)
}

// GetShare operation middleware
func (siw *ServerInterfaceWrapper) GetShare(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShareParams

	// ------------- Required query parameter "thread_id" -------------

	if paramValue := c.Query("thread_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument thread_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "thread_id", c.Request.URL.Query(), &params.ThreadId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter thread_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetShare(c, params)
}

// PostThreadScrape operation middleware
func (siw *ServerInterfaceWrapper) PostThreadScrape(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostThreadScrape(c)
}

// GetThreadId operation middleware
func (siw *ServerInterfaceWrapper) GetThreadId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetThreadId(c, id)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.GET(options.BaseURL+"/mentions", wrapper.GetMentions)
	router.GET(options.BaseURL+"/qrcode", wrapper.GetQrcode)
	router.GET(options.BaseURL+"/render", wrapper.GetRender)
	router.GET(options.BaseURL+"/share", wrapper.GetShare)
	router.POST(options.BaseURL+"/thread/scrape", wrapper.PostThreadScrape)
	router.GET(options.BaseURL+"/thread/:id", wrapper.GetThreadId)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
