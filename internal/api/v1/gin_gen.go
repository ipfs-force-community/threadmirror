// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Get mentions feed
	// (GET /mentions)
	GetMentions(c *gin.Context, params GetMentionsParams)
	// Render QR code
	// (GET /qrcode)
	GetQrcode(c *gin.Context, params GetQrcodeParams)
	// Render thread as HTML
	// (GET /render)
	GetRender(c *gin.Context, params GetRenderParams)
	// Download share image
	// (GET /share)
	GetShare(c *gin.Context, params GetShareParams)
	// Scrape Twitter thread from URL (Async)
	// (POST /thread/scrape)
	PostThreadScrape(c *gin.Context)
	// Get thread details
	// (GET /thread/{id})
	GetThreadId(c *gin.Context, id string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// GetMentions operation middleware
func (siw *ServerInterfaceWrapper) GetMentions(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMentionsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetMentions(c, params)
}

// GetQrcode operation middleware
func (siw *ServerInterfaceWrapper) GetQrcode(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetQrcodeParams

	// ------------- Required query parameter "thread_id" -------------

	if paramValue := c.Query("thread_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument thread_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "thread_id", c.Request.URL.Query(), &params.ThreadId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter thread_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetQrcode(c, params)
}

// GetRender operation middleware
func (siw *ServerInterfaceWrapper) GetRender(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRenderParams

	// ------------- Required query parameter "thread_id" -------------

	if paramValue := c.Query("thread_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument thread_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "thread_id", c.Request.URL.Query(), &params.ThreadId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter thread_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "lang" -------------

	err = runtime.BindQueryParameter("form", true, false, "lang", c.Request.URL.Query(), &params.Lang)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter lang: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "source_lang" -------------

	err = runtime.BindQueryParameter("form", true, false, "source_lang", c.Request.URL.Query(), &params.SourceLang)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter source_lang: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRender(c, params)
}

// GetShare operation middleware
func (siw *ServerInterfaceWrapper) GetShare(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShareParams

	// ------------- Required query parameter "thread_id" -------------

	if paramValue := c.Query("thread_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument thread_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "thread_id", c.Request.URL.Query(), &params.ThreadId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter thread_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "scale" -------------

	err = runtime.BindQueryParameter("form", true, false, "scale", c.Request.URL.Query(), &params.Scale)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter scale: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "lang" -------------

	err = runtime.BindQueryParameter("form", true, false, "lang", c.Request.URL.Query(), &params.Lang)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter lang: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "source_lang" -------------

	err = runtime.BindQueryParameter("form", true, false, "source_lang", c.Request.URL.Query(), &params.SourceLang)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter source_lang: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetShare(c, params)
}

// PostThreadScrape operation middleware
func (siw *ServerInterfaceWrapper) PostThreadScrape(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostThreadScrape(c)
}

// GetThreadId operation middleware
func (siw *ServerInterfaceWrapper) GetThreadId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetThreadId(c, id)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.GET(options.BaseURL+"/mentions", wrapper.GetMentions)
	router.GET(options.BaseURL+"/qrcode", wrapper.GetQrcode)
	router.GET(options.BaseURL+"/render", wrapper.GetRender)
	router.GET(options.BaseURL+"/share", wrapper.GetShare)
	router.POST(options.BaseURL+"/thread/scrape", wrapper.PostThreadScrape)
	router.GET(options.BaseURL+"/thread/:id", wrapper.GetThreadId)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
