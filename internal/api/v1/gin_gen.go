// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Get mentions feed
	// (GET /mentions)
	GetMentions(c *gin.Context, params GetMentionsParams)
	// Render QR code
	// (GET /qrcode)
	GetQrcode(c *gin.Context, params GetQrcodeParams)
	// Render thread as HTML
	// (GET /render)
	GetRender(c *gin.Context, params GetRenderParams)
	// Download share image
	// (GET /share)
	GetShare(c *gin.Context, params GetShareParams)
	// Get thread details
	// (GET /thread/{id})
	GetThreadId(c *gin.Context, id string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// GetMentions operation middleware
func (siw *ServerInterfaceWrapper) GetMentions(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMentionsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetMentions(c, params)
}

// GetQrcode operation middleware
func (siw *ServerInterfaceWrapper) GetQrcode(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetQrcodeParams

	// ------------- Required query parameter "thread_id" -------------

	if paramValue := c.Query("thread_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument thread_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "thread_id", c.Request.URL.Query(), &params.ThreadId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter thread_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetQrcode(c, params)
}

// GetRender operation middleware
func (siw *ServerInterfaceWrapper) GetRender(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRenderParams

	// ------------- Required query parameter "thread_id" -------------

	if paramValue := c.Query("thread_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument thread_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "thread_id", c.Request.URL.Query(), &params.ThreadId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter thread_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRender(c, params)
}

// GetShare operation middleware
func (siw *ServerInterfaceWrapper) GetShare(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShareParams

	// ------------- Required query parameter "thread_id" -------------

	if paramValue := c.Query("thread_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument thread_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "thread_id", c.Request.URL.Query(), &params.ThreadId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter thread_id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetShare(c, params)
}

// GetThreadId operation middleware
func (siw *ServerInterfaceWrapper) GetThreadId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetThreadId(c, id)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.GET(options.BaseURL+"/mentions", wrapper.GetMentions)
	router.GET(options.BaseURL+"/qrcode", wrapper.GetQrcode)
	router.GET(options.BaseURL+"/render", wrapper.GetRender)
	router.GET(options.BaseURL+"/share", wrapper.GetShare)
	router.GET(options.BaseURL+"/thread/:id", wrapper.GetThreadId)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
