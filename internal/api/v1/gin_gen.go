// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get bot statistics
	// (GET /bot/stats)
	GetBotStats(c *gin.Context)
	// Health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Get posts feed
	// (GET /posts)
	GetPosts(c *gin.Context, params GetPostsParams)
	// Get post details
	// (GET /posts/{id})
	GetPostsId(c *gin.Context, id string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetBotStats operation middleware
func (siw *ServerInterfaceWrapper) GetBotStats(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetBotStats(c)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// GetPosts operation middleware
func (siw *ServerInterfaceWrapper) GetPosts(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPostsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", c.Request.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter offset: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPosts(c, params)
}

// GetPostsId operation middleware
func (siw *ServerInterfaceWrapper) GetPostsId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPostsId(c, id)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/bot/stats", wrapper.GetBotStats)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.GET(options.BaseURL+"/posts", wrapper.GetPosts)
	router.GET(options.BaseURL+"/posts/:id", wrapper.GetPostsId)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AQAA//9XQ5GS9CkAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
